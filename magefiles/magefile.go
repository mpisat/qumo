//go:build mage

package main

import (
	"bufio"
	"crypto/sha256"
	"crypto/x509"
	"encoding/hex"
	"encoding/pem"
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"strings"
	"time"

	"github.com/magefile/mage/mg"
	"github.com/magefile/mage/sh"
)

// Default target to run when none is specified
var Default = Help

// Help displays available mage targets
func Help() error {
	fmt.Println("ğŸ“– qumo-relay - Native Binary Deployment with Nomad")
	fmt.Printf("   Platform: %s/%s\n", runtime.GOOS, runtime.GOARCH)
	fmt.Println()
	fmt.Println("Available targets:")
	fmt.Println()
	fmt.Println("  ğŸï¸  Nomad Orchestration:")
	fmt.Println("    mage nomad:agent  - Start Nomad agent in dev mode")
	fmt.Println("    mage nomad:up     - Build and deploy to Nomad")
	fmt.Println("    mage nomad:stop   - Stop Nomad job")
	fmt.Println("    mage nomad:status - Show job status")
	fmt.Println("    mage nomad:logs   - Show job logs")
	fmt.Println("    mage nomad:clean  - Clean Nomad artifacts")
	fmt.Println()
	fmt.Println("  ğŸŒ Web Demo:")
	fmt.Println("    mage relay        - Start relay server only (run from repo root)")
	fmt.Println("    mage web          - Start web demo (Vite dev server only)")
	fmt.Println("    mage webBuild     - Build web demo for production")
	fmt.Println("    mage webClean     - Clean web build artifacts")
	fmt.Println()
	fmt.Println("  ğŸ”§ Utilities:")
	fmt.Println("    mage cert         - Generate TLS certificates using mkcert")
	fmt.Println("    mage hash         - Compute/write TLS cert SHA-256 (writes web cert hash file for dev)")
	fmt.Println("    mage clean        - Clean build artifacts")
	fmt.Println()
	fmt.Println("  â„¹ï¸  Info:")
	fmt.Println("    mage -l           - List all targets")
	fmt.Println("    mage help         - Show this help")
	fmt.Println()
	return nil
}

// Relay starts the qumo-relay server
func Relay() error {
	fmt.Println("ğŸ“¡ Starting qumo-relay server...")
	fmt.Println("   Config: ./config.yaml (see configs/config.example.yaml)")
	fmt.Println("   Certs: certs/server.crt, certs/server.key (generated by 'mage cert')")
	fmt.Println()

	cmd := exec.Command("go", "run", "../cmd/qumo-relay")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

// Web starts the web demo application (Vite dev server only)
// Note: Start relay separately with `./bin/qumo-relay` or `mage relay`
func Web() error {
	fmt.Println("ğŸŒ Starting web demo...")
	fmt.Println("   Web Demo: http://localhost:5173")
	fmt.Println()
	fmt.Println("âš ï¸  Make sure relay is running separately:")
	fmt.Println("   ./bin/qumo-relay  # or: mage relay")
	fmt.Println()

	// Start Vite dev server in the solid-deno project
	webDir := "../solid-deno"
	cmd := exec.Command("npm", "run", "dev")
	cmd.Dir = webDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

// WebBuild builds the web demo for production
func WebBuild() error {
	fmt.Println("ğŸ”¨ Building web demo...")

	cmd := exec.Command("npm", "run", "build")
	cmd.Dir = "../solid-deno"
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

// WebClean cleans web build artifacts
func WebClean() error {
	fmt.Println("ğŸ§¹ Cleaning web artifacts...")
	return sh.Rm("../solid-deno/dist")
}

// Cert generates TLS certificates using mkcert
func Cert() error {
	fmt.Println("ğŸ” Generating TLS certificates...")

	// Check if mkcert is installed
	if err := exec.Command("mkcert", "-version").Run(); err != nil {
		fmt.Println("âŒ mkcert is not installed!")
		fmt.Println()
		fmt.Println("Please install mkcert:")
		fmt.Println("  Windows: winget install FiloSottile.mkcert")
		fmt.Println("  macOS:   brew install mkcert")
		fmt.Println("  Linux:   See https://github.com/FiloSottile/mkcert#installation")
		return fmt.Errorf("mkcert not found")
	}

	// Ensure certs directory exists
	if err := os.MkdirAll("../certs", 0755); err != nil {
		return err
	}

	// Install local CA if not already installed
	fmt.Println("ğŸ“¦ Setting up local CA...")
	installCmd := exec.Command("mkcert", "-install")
	installCmd.Stdout = os.Stdout
	installCmd.Stderr = os.Stderr
	if err := installCmd.Run(); err != nil {
		fmt.Println("âš ï¸  Warning: Failed to install CA, continuing anyway...")
	}

	// Generate certificates for localhost
	fmt.Println("ğŸ“ Generating certificates for localhost...")
	certCmd := exec.Command("mkcert",
		"-cert-file", "../certs/server.crt",
		"-key-file", "../certs/server.key",
		"localhost", "127.0.0.1", "::1")
	certCmd.Stdout = os.Stdout
	certCmd.Stderr = os.Stderr
	if err := certCmd.Run(); err != nil {
		return fmt.Errorf("failed to generate certificates: %w", err)
	}

	// Compute SHA-256 of the generated certificate and write to certs/server.crt.sha256
	err := Hash()
	if err != nil {
		fmt.Println("âš ï¸  Warning: failed to compute cert hash:", err)
	}

	fmt.Println()
	fmt.Println("âœ… Certificates generated successfully!")
	fmt.Println("   ğŸ“„ certs/server.crt")
	fmt.Println("   ğŸ”‘ certs/server.key")
	fmt.Println()
	fmt.Println("ğŸ’¡ These certificates are trusted by your system")
	fmt.Println("   You can now use WebTransport without certificate errors!")
	return nil
}

// computeCertHash reads the PEM certificate at certs/server.crt, computes
// the SHA-256 hex fingerprint and returns it as a lower-case hex string.
func computeCertHash() (string, error) {
	b, err := os.ReadFile("../certs/server.crt")
	if err != nil {
		return "", fmt.Errorf("failed to read cert: %w", err)
	}
	block, _ := pem.Decode(b)
	if block == nil {
		return "", fmt.Errorf("failed to decode PEM")
	}
	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		return "", fmt.Errorf("failed to parse certificate: %w", err)
	}
	sha := sha256.Sum256(cert.Raw)
	hexStr := hex.EncodeToString(sha[:])
	return hexStr, nil
}

// copyToClipboard attempts to copy the provided text to the system clipboard
// using platform-appropriate utilities. Returns an error if the required
// clipboard tool is not available or if the copy fails.
func copyToClipboard(text string) error {
	var cmd *exec.Cmd
	switch runtime.GOOS {
	case "windows":
		// Use clip.exe via cmd to avoid issues
		cmd = exec.Command("cmd", "/c", "clip")
	case "darwin":
		cmd = exec.Command("pbcopy")
	default:
		// Try wl-copy (Wayland), then xclip, then xsel
		if _, err := exec.LookPath("wl-copy"); err == nil {
			cmd = exec.Command("wl-copy")
		} else if _, err := exec.LookPath("xclip"); err == nil {
			cmd = exec.Command("xclip", "-selection", "clipboard")
		} else if _, err := exec.LookPath("xsel"); err == nil {
			cmd = exec.Command("xsel", "--clipboard", "--input")
		} else {
			return fmt.Errorf("no clipboard utility found (install wl-clipboard, xclip, or xsel)")
		}
	}

	in, err := cmd.StdinPipe()
	if err != nil {
		return err
	}
	if err := cmd.Start(); err != nil {
		return err
	}
	if _, err := in.Write([]byte(text)); err != nil {
		_ = in.Close()
		return err
	}
	_ = in.Close()
	return cmd.Wait()
}

// Hash computes (or re-computes) the certificate SHA-256 hash and prints the
// result. Optionally copies it to the system clipboard when run interactively.
func Hash() error {
	hexStr, err := computeCertHash()
	if err != nil {
		return err
	}
	fmt.Println("-----------ğŸ” CERT HASH-------------")
	fmt.Println("")
	fmt.Println(hexStr)
	fmt.Println("")
	fmt.Println("------------------------------------")

	// If stdin is not a TTY, avoid prompting and skip copying
	fi, _ := os.Stdin.Stat()
	if (fi.Mode() & os.ModeCharDevice) == 0 {
		fmt.Println("Non-interactive stdin detected; skipping clipboard copy. Run 'mage hash' interactively to copy the hash to the clipboard.")
		return nil
	}

	reader := bufio.NewReader(os.Stdin)
	fmt.Print("Do you want to copy this hash to the clipboard? (y/n): ")
	input, _ := reader.ReadString('\n')
	input = strings.TrimSpace(input)
	if len(input) > 0 && (input[0] == 'y' || input[0] == 'Y') {
		if err := copyToClipboard(hexStr); err != nil {
			return fmt.Errorf("failed to copy to clipboard: %w", err)
		}
		fmt.Println("ğŸ” Copied cert hash to clipboard")
	} else {
		fmt.Println("Skipping clipboard copy.")
	}

	return nil
}

// Clean removes build artifacts
func Clean() error {
	fmt.Println("ğŸ§¹ Cleaning build artifacts...")
	return sh.Rm("../bin")
}

// Nomad provides Nomad-specific commands
type Nomad mg.Namespace

// Agent starts the Nomad agent in dev mode
func (Nomad) Agent() error {
	fmt.Println("ğŸƒ Starting Nomad Agent (Dev Mode)...")
	fmt.Println("   Access UI at http://localhost:4646")

	cmd := exec.Command("nomad", "agent", "-dev")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

// Build builds the Go binary for Nomad
func (Nomad) Build() error {
	fmt.Println("ğŸ”¨ Building qumo-relay binary...")

	binaryName := "qumo-relay"
	if runtime.GOOS == "windows" {
		binaryName += ".exe"
	}

	// Ensure build directory exists
	if err := os.MkdirAll("../bin", 0755); err != nil {
		return err
	}

	cmd := exec.Command("go", "build", "-o", "../bin/"+binaryName, "../cmd/qumo-relay")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

// Up builds and deploys the job to Nomad
func (Nomad) Up() error {
	mg.Deps(Nomad.Build)

	fmt.Println("ğŸš€ Submitting Job to Nomad...")
	cmd := exec.Command("nomad", "job", "run", "../moq-relay.nomad")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

// Stop stops the Nomad job
func (Nomad) Stop() error {
	fmt.Println("ğŸ›‘ Stopping Nomad job...")
	cmd := exec.Command("nomad", "job", "stop", "moq-relay")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

// Status shows the Nomad job status
func (Nomad) Status() error {
	fmt.Println("ğŸ“Š Job Status:")
	cmd := exec.Command("nomad", "job", "status", "moq-relay")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

// Logs shows the Nomad job logs
func (Nomad) Logs() error {
	fmt.Println("ğŸ“‹ Job Logs:")
	cmd := exec.Command("nomad", "alloc", "logs", "-job", "moq-relay", "-f")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

// Clean removes Nomad artifacts
func (Nomad) Clean() error {
	fmt.Println("ğŸ§¹ Cleaning Nomad artifacts...")
	// Optionally stop the job first
	_ = Nomad{}.Stop()
	time.Sleep(1 * time.Second)
	return sh.Rm("../bin")
}
